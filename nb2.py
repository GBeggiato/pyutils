"""
[N]ote[B]ook to .[PY]thon

converts Jupiter notebooks to plain python files
"""


import argparse
from datetime import datetime
import itertools
import json
from pathlib import Path
import typing as ty


CELLS = "cells"
CELL_TYPE = "cell_type"
SOURCE = "source"
CODE = "code"

THIS_FILE = Path(__file__).name



class _Args(ty.NamedTuple):
    inpt: Path
    outpt: Path | None


def parse_args() -> _Args | None:
    parser = argparse.ArgumentParser(
        prog=f"python3 {THIS_FILE}",
        description="converts Jupiter notebooks to plain python files",
    )
    parser.add_argument("input", help="input file to convert")
    parser.add_argument("-o", help="output folder, if not provided it prints the output to the screen")
    parsed = parser.parse_args()

    inpt = Path(parsed.input)
    if not inpt.exists():
        print(f"not found: {inpt}")
        return None
    outpt = None
    if parsed.o:
        outpt = Path(parsed.o)
        if not outpt.is_dir():
            print(f"not a directory: {outpt}")
            return None
        if not outpt.exists():
            print(f"not found: {outpt}")
            return None
    return _Args(inpt, outpt)


def _validate(f: Path) -> list[str]:
    with f.open() as fp:
        source = json.load(fp)
    lines = []
    assert isinstance(source, dict)
    assert source.get(CELLS) is not None
    cells = source[CELLS]
    assert isinstance(cells, list)
    for c in cells:
        assert c.get(CELL_TYPE) is not None
        assert c.get(SOURCE) is not None
        if c[CELL_TYPE] != CODE:
            continue
        for s in c[SOURCE]:
            assert isinstance(s, str)
            lines.append(s)
    return lines


def _codegen(lines: list[str]) -> list[str]:
    _ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    code = [f"# automatically generated by {THIS_FILE} on {_ts}", "\n\n"]
    code.extend(lines)
    return code


def _show(args: _Args, code: list[str]):
    if args.outpt is None:
        for line in code:
            print(line)
    elif isinstance(args.outpt, Path):
        out = args.outpt / f"{args.inpt.stem}_converted.py"
        out.write_text("\n".join(code))
        print(f"saved output to {out}")


def main():
    args = parse_args()
    if args is None:
        return
    try:
        lines = _validate(args.inpt)
    except AssertionError:
        print(f"could not parse {args.inpt}")
        return
    code = _codegen(lines)
    _show(args, code)


if __name__ == "__main__":
    main()

